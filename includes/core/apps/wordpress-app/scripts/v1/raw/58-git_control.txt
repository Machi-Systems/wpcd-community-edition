#!/bin/bash
if [[ "$EUID" -ne 0 ]]
then
	echo "Sorry, you need to run this as root"
	exit
fi

## Get our common functions
if [[ ! -f 9999-common-functions.sh ]]
then
	echo "The file 9999-common-functions.sh is missing"
	exit
fi
source 9999-common-functions.sh


########################################################
# Send callback failed.
#
# @param $1 callback url
# @param $2 message to send.
########################################################
lf_send_callback_failed() {

	# setup local variables from parameters passed in.
	local git_callback_url
	local msg
	git_callback_url=$1
	msg="$2"

	# @note msg will contain spaces so might need to encode it somehow for curl.

	# echo "In function to send callback to host with failure msg for: $git_callback_url $msg"
}

########################################################
# Common function to get domain we want to work with.
#
# returns $domain
########################################################
lf_select_domain () {
	while [[ -z $domain ]]
	do
		clear
		echo "Please, select which site you want to work with"
		gf_select_domain
		domain=$(ls /var/www | grep -v html | sed -n "$site_number"p)
	done
}

########################################################
# Given a domain, navigate to it's var/www folder.
#
# If unable to navigate there, exit completely.
#
# @param $1 domain
########################################################
lf_navigate_to_domain_folder() {

	# setup local variables from parameters passed in.
	local domain
	domain=$1

	# move into the domain folder
	cd /var/www/$domain/html
	if [ $? -ne 0 ]	
	then
		msg="Unable to navigate to /var/www/$domain/html."
		echo $msg
		exit
	fi		
}

########################################################
# This is the start of a series of functions to collect
# Data from the user.
#
# returns $domain
########################################################
lf_get_git_branch() {
	while [[ -z $git_branch ]]
	do
		read -p "What branch are we working with? " git_branch
	done
	echo "Branch is: $git_branch"
}

lf_get_new_git_branch() {
	while [[ -z $git_new_branch ]]
	do
		read -p "What is the name of the new branch?? " git_new_branch
	done
	echo "New branch is: $git_new_branch"
}

lf_get_git_user_email() {
	while [[ -z $git_user_email ]]
	do
		read -p "What is the email address for the git user account? " git_user_email
	done
	echo "Email is: $git_user_email"
}

lf_get_git_display_name() {
	while [[ -z $git_display_name ]]
	do
		read -p "What is the display name for the git user account? Example John Smith: " git_display_name
	done
	echo "Display Name is: $git_display_name"
}

lf_get_git_username() {
	while [[ -z $git_user_name ]]
	do
		read -p "What is the user name for the git user account? Example jsmith: " git_user_name
	done
	echo "User Name is: $git_user_name"
}

lf_get_git_remote_url() {
	while [[ -z $git_remote_url ]]
	do
		read -p "What is the remote url for the repository? Example https://github.com/jsmith/myrepo: " git_remote_url
	done
	echo "Repo is: $git_remote_url"
}

lf_get_git_token() {
	while [[ -z $git_token ]]
	do
		read -p "What is the security token for the repo/account: " git_token
	done
	echo "Repo token is: ***secret - not shown***"
}

lf_get_git_ignore_url() {
	# gitignore default url is allowed to be blank.
	if [[ -z $git_ignore_url ]]; then
		read -p "Enter the URL where the default git_ignore file is located: " git_ignore_url
	fi
	echo "Git Ignore URL is: $git_ignore_url"
}

lf_get_commit_message() {
	while [[ -z $git_commit_msg ]]
	do
		read -p "Enter a commit message - it will be used if there are any uncommitted changes: " git_commit_msg
	done
	echo "Git Commit Message Is: $git_commit_msg"
}

lf_get_git_pre_processing_script_link() {
	if [[ -z $git_pre_processing_script_link ]]; then
		read -p "[optional] Enter the URL where the pre-processing link is located: " git_pre_processing_script_link
		echo "Pre-processing Script URL is: $git_pre_processing_script_link"
	fi
}

lf_get_git_post_processing_script_link () {
	if [[ -z $git_post_processing_script_link ]]; then
		read -p "[optional] Enter the URL where the post-processing link is located: " git_post_processing_script_link
		echo "Post-processing Script URL is: $git_post_processing_script_link"
	fi
}

lf_get_exclude_folders() {
	if [[ -z $git_exclude_folders ]]; then
		read -p "[optional] Exclude folders for gitignore (comma separated list): " git_exclude_folders
		echo "Folders Excluded Are: $git_exclude_folders"
	fi
}

lf_get_exclude_files() {
	if [[ -z $git_exclude_files ]]; then
		read -p "[optional] Exclude files for gitignore (comma separated list): " git_exclude_files
		echo "Files Excluded Are: $git_exclude_files"
	fi
}

lf_get_callback_url() {
	if [[ -z $git_callback_url ]]; then
		read -p "[optional] Enter the Callback URL: " git_callback_url
		echo "Callback URL is: $git_callback_url"
	fi
}

lf_get_tag() {
	while [[ -z $git_tag ]]
	do
		read -p "Enter a tag: " git_tag
	done
	echo "Git Tag Is: $git_tag"
}

lf_mt_get_template_domain() {
#	while [[ -z $mt_template_domain ]]
#	do
#		read -p "Enter the template domain for this operation: " mt_template_domain
#	done
#	echo "The Multi-tenant template site for this operation is: $mt_template_domain"

	echo
	ls /var/wpcd-mt-versions | grep -v html | nl
	read -p "Select versioned template domain on this server: " site_number
	number_of_sites=$(ls /var/wpcd-mt-versions | grep -v html | wc -l)
	until [[ "$site_number" =~ ^[0-9]+$ && "$site_number" -le "$number_of_sites" ]]
	do
			echo "$site_number: invalid selection."
			read -p "Select site: " site_number
	done

	mt_template_domain=$(ls /var/wpcd-mt-versions | grep -v html | sed -n "$site_number"p)

	echo "Versioned template you have chosen is: $mt_template_domain"
}

########################################################
# Function to detect whether git is already installed.
#
# returns $iv_get_available: 1 or 0
########################################################
lf_is_git_installed() {

	git --version 2>&1 >/dev/null

	GIT_IS_AVAILABLE=$?

	# Really need a way to check version and make sure it's 2.39 or later.

	# Set variable
	if [ $GIT_IS_AVAILABLE -eq 0 ]; then
		iv_git_available=1
	else
		iv_git_available=0
	fi
}

########################################################
# Function to install git on the server.
#
# @Todo: Check version installed and only upgrade
# if not the version we need.
########################################################
lf_git_install() {

	# run function to check if git is installed.
	lf_is_git_installed

	# check output variable from above function.
	if [ $iv_git_available -eq 0 ]; then
		echo "Git is not installed - installing..."
	else
		echo "Git is already installed. Updating to latest version..."
	fi

	# add git maintainer repo.
	sudo add-apt-repository ppa:git-core/ppa -y
	sudo apt-get update
	sudo apt-get -y install git
	echo
	echo "Git has been installed."
	exit

}


########################################################
# Function to update git to latest version.
########################################################
lf_git_update() {
	sudo apt-get update
	sudo apt-get -y install git
	echo
	echo "Git has been updated."
	exit
}

########################################################
# Function to create gitignore
#
# Assumes we are already in the $domain/html folder.
#
# @param $1 The url to the default git_ignore file.
# @param $2 exclude folders list
# @param $3 exclue files list
########################################################
lf_create_git_ignore() {

	# setup local variables from parameters passed in.
	local git_ignore_url
	local git_exclude_folders
	local git_exclude_files
	git_ignore_url=$1
	git_exclude_folders=$2
	git_exclude_files=$3

	# Get the default gitignore file.
	if [[ -n $git_ignore_url ]]; then	
		echo "Downloading default gitignore file..."
		wget --quiet --no-check-certificate -O .gitignore $git_ignore_url
		dos2unix .gitignore
	fi

	# Add in the things we definitely want in there.
	echo "#################################"  >> .gitignore
	echo "# WPCD Defaults"  >> .gitignore
	echo "#################################"  >> .gitignore
	echo "wp-config.php" >> .gitignore
	echo "logs/" >> .gitignore	
	echo "filemanager/" >> .gitignore
	echo "phpmyadmin/" >> .gitignore
	echo "wp-content/debug.log" >> .gitignore
	echo "wp-content/downloads" >> .gitignore
	echo "wp-content/updraft" >> .gitignore
	echo "*.log" >> .gitignore
	echo "*.env" >> .gitignore
	echo "*.env.*" >> .gitignore

	# Keepers
	echo "!.env.example" >> .gitignore

	# User defined files and folders
	echo "#################################"  >> .gitignore
	echo "# WPCD User Provided"  >> .gitignore
	echo "#################################"  >> .gitignore
	# Break folders using comma as separator
	array=()
	while IFS= read -r line; do
		array+=("$line")
	done < <(tr ',' '\n' <<< "$git_exclude_folders")

	for item in "${array[@]}"; do
		echo "$item"  >> .gitignore
	done

	# Break files using comma as separator
	array=()
	while IFS= read -r line; do
		array+=("$line")
	done < <(tr ',' '\n' <<< "$git_exclude_files")

	for item in "${array[@]}"; do
		echo "$item"  >> .gitignore
	done
}

########################################################
# Function to remove git files from a domain.
#
# @param $1 The domain.
########################################################
lf_remove_git_from_domain() {

	# setup local variables from parameters passed in.
	local domain
	domain=$1

	echo "Removing existing git files if any..."
	if [[ -z $domain ]]
	then
		msg="We are about to delete a folder but the domain variable is blank. Operation aborted."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url $msg
		return 1  #return error.
	else
		rm -rf /var/www/$domain/.wpcd_git
		rm -rf /var/www/$domain/html/.git
		rm -rf /var/www/$domain/html/.gitignore
		# @todo - perhaps remove domain from credential helper and global safe-domain file?
	fi
}

########################################################
# Function to fetch tag from remote and create version
# folder.
#
# @param $1 The domain.
# @param $2 The tag
# @param $3 'standard' or 'mt'.  'Standard' places files under the /var/www/$domain folder. 'mt' places them under /var/wpcd-mt-versions/$domain/$ver-tag-branch
# @param $4 (optional) value should be 'pull' - this will let us PULL & Checkout files and sync instead of fetching only.
########################################################
lf_git_fetch_or_pull_tag() {

	# setup local variables from parameters passed in.
	local domain
	local git_tag
	local op_type
	local do_pull
	domain=$1
	git_tag=$2
	op_type=$3
	do_pull=$4

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	# which folder will we be placing files into?
	if [ 'standard' == $op_type	]
	then
		target_folder="/var/www/$domain/versions/$git_tag"
	fi
	if [ 'mt' == $op_type	]
	then
		target_folder="/var/wpcd-mt-versions/$domain/versions/$git_tag"
	fi

	# if we don't have a target folder exit.
	if [[ -z $target_folder ]]; then
		echo
		msg="Could not figure out the target folder based on the provided operation type ($op_type). Exiting."
		echo $msg
		exit
	fi

	# Create folder where tagged files will go.
	mkdir -p $target_folder
	if [ $? -ne 0 ]
	then
		echo
		msg="Could not create folder $target_folder"
		echo $msg
		exit
	fi

	# Fetch all tags in case the requested tag isn't known.
	git fetch --all --tags	
	if [ $? -ne 0 ]
	then
		msg="Could not refresh all tags from remote to local."
		echo
		echo $msg
		exit
	fi

	# Find out which branch a tag is located on.
	# We're not using this info in here but good to have for the logs.
	local tag_branch
	tag_branch=$(git branch -a --contains $git_tag)
	echo "Tag is located on branch $tag_branch"	

	if [ "pull" == "do_pull" ]
	then
		git pull origin $git_tag
		if [ $? -ne 0 ]
		then
			msg="Could not pull tag $git_tag from remote."
			echo
			echo $msg
			exit
		fi

		# Lets checkout the tag.
		local current_branch
		current_branch=$(git rev-parse --abbrev-ref HEAD)
		echo "Current branch is $current_branch - we are checking out tag $git_tag"
		git checkout $git_tag
		if [ $? -ne 0 ]
		then
			msg="Could not checkout tag $git_tag"
			echo
			echo $msg
			exit
		fi
	fi		

	# Add tagged files to that folder as .zip.
	echo "Creating temporary zip of tagged files..."
	git archive --format=zip --output=$target_folder/$git_tag.zip $git_tag
	if [ $? -ne 0 ]
	then
		msg="Could not create zip file in folder $target_folder/ for tag $git_tag."
		echo
		echo $msg
		exit
	fi

	# Unzip files so they're ready for use later.
	echo "Copying files into the versions folder ($target_folder)"
	unzip -q -o $target_folder/$git_tag.zip -d $target_folder
	if [ $? -ne 0 ]
	then
		msg="Could not unzip tagged files for $git_tag."
		echo
		echo $msg
		exit
	fi

	# If op_type is 'mt', create a 'wp' core folder.
	if [ 'mt' == $op_type	]
	then
		#target_folder="/var/wpcd-mt-versions/$domain/versions/$git_tag"
		# make wp folder and copy wp-includes and wp-admin
		mkdir -p $target_folder/wp
		cp  -r "$target_folder/wp-includes" "$target_folder/wp/"
		cp  -r "$target_folder/wp-admin" "$target_folder/wp/"
		
		# list of files in wp-core.
		core_files=( 'index.php' 'license.txt' 'readme.html' 'wp-activate.php' 'wp-signup.php' 'wp-blog-header.php' 'wp-comments-post.php' 'wp-config-sample.php' 'wp-cron.php' 'wp-links-opml.php' 'wp-load.php' 'wp-login.php' 'wp-mail.php' 'wp-settings.php' 'wp-signup.ph' 'wp-trackback.php' 'xmlrpc.php' )

		# navigate to versions folder.
		cd $target_folder
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $target_folder"
			echo
			echo $msg
			exit
		fi
		for core_file in "${core_files[@]}"
		do
			if [ -f "$core_file" ]; then	
				cp "$target_folder/$core_file" "$target_folder/wp/$core_file"
				if [ $? -ne 0 ]
				then
					msg="Unable to copy file from: $target_folder/$core_file to $target_folder/wp/$core_file"
					echo
					echo $msg
					exit
				fi
			else
				msg="Core WP file not found in version folder ($core_file) - moving on."
			fi
		done		
	fi	

	# @TODO: If op_type is 'mt' OR do_pull is empty (which means we're only fetching files)
	# then make everything in the versions folder read-only.

	# Remove zip file.
	rm -f $target_folder/$git_tag.zip	

}

########################################################
# Get action to perform
########################################################
while [[ -z $action ]]
do
	echo "What do you want to do?"
	echo "   1) Install git on the server"
	echo "   2) Update git to latest version"
	echo "   3) Initialize git on a domain"
	echo "   4) Remove git from a domain"
	echo "   5) Sync with remote/origin (pull & push)"
	echo "   6) Switch branch & checkout"
	echo "   7) Add new branch and checkout"
	echo "   8) Commit and push to remote/origin"
	echo "   9) Add tag to current branch"
	echo "   10) Pull tag and create version"
	echo "   11) Remove a version folder"
	echo "   12) Remove all version folders for a site"
	echo "   13) Display all version folders for a site"
	echo "   14) Display current branch"
	echo "   15) Apply version to domain with overwrite (Fetch)"
	echo "   16) Pull & Apply version to domain with overwrite (Syncs site and repo with tag)"
	echo "   17) Setup or change git credentials for a site"
	echo "   18) Clone remote repo to a domain (bare)"
	echo "   19) Reserved for future use"
	echo "   20) Reserved for future use"
	echo "*************************************************************************************"
	echo "* Start of multi-tenant options"
	echo "*************************************************************************************"
	echo "   21) Fetch Multi-tenant version (tag)"
	echo "   22) Convert site to multi-tenant"
	echo
	read -p "Action: " action
	until [[ -z "$action" || "$action" =~ ^[1-9]|2[0-9]|3[0-9]$ ]]
	do
		echo "$action: invalid selection."
		read -p "Action: " action
	done
done

########################################################
# Below are blocks where the action choosen above
# is performed.
########################################################

# Install git on server
if [[ $action == "git_install" || $action == "1" ]]
then
	lf_git_install
fi

# Update git to latest version
if [[ $action == "git_update" || $action == "2" ]]
then
	lf_git_update
fi

if [[ $action == "git_init" || $action == "3" ]]
then
	# Start with a blank screen
	clear

	# Get domain - output will be in $domain.
	lf_select_domain							# Sets Global $domain

	lf_get_git_branch							# Sets Global $git_branch
	lf_get_git_user_email						# Sets Global $git_user_email
	lf_get_git_display_name						# Sets Global $git_display_name
	lf_get_git_username							# Sets Global $git_user_name
	lf_get_git_remote_url						# Sets Global $git_remote_url
	lf_get_git_token							# Sets Global $git_token
	lf_get_git_ignore_url						# Sets Global $git_ignore_url
	lf_get_git_pre_processing_script_link		# Sets Global $git_pre_processing_script_link
	lf_get_git_post_processing_script_link		# Sets Global $git_post_processing_script_link
	lf_get_exclude_folders						# Sets Global $git_exclude_folders
	lf_get_exclude_files						# Sets Global $git_exclude_files
	lf_get_callback_url							# Sets Global $git_callback_url

	# Remove any existing git working folders.
	lf_remove_git_from_domain $domain
	if [ $? -ne 0 ]
	then
		echo
		echo "Unable to remove git from $domain. Aborting..."
		exit
	fi

	# Make a git working folder outside of the folder where files are usually located.
	# We will NOT be backing up this folder.
	mkdir -p /var/www/$domain/.wpcd_git
	if [ $? -ne 0 ]
	then
		msg="Could not create folder $domain/.wpcd_git"
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Move into git working folder.
	cd /var/www/$domain/.wpcd_git
	if [ $? -ne 0 ]
	then
		msg="Could not move into folder /var/www/$domain/.wpcd_git."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi		

	# Initialize git and check for error.
	git init -b $git_branch --separate-git-dir . ../html/
	if [ $? -ne 0 ]
	then
		msg="Could not initialize repo."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Run pre-processing script if provided and check for error.
	if [[ -n "$git_pre_processing_script_link" ]]
	then
		tmpfile=$(mktemp)
		echo
		echo "Running pre-processing script as temp file: $tmpfile"
		wget --quiet --no-check-certificate -O $tmpfile $git_pre_processing_script_link
		dos2unix $tmpfile
		bash $tmpfile
	fi

	# Since $domain and .wpcd_git are owned by different users (root vs limited user), need to mark $domain as safe.
	echo "Adding global safe.directory variable for domain $domain..."
	git config --global --add safe.directory /var/www/$domain/html
	if [ $? -ne 0 ]	
	then
		msg="Unable to mark $domain as safe using git config --global -add safe.directory."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Even if this script is called with 'sudo', git will write the global data
	# to the sudo (eg: ubuntu) folder. So nest sudo calls which will 
	# force it to write to the root home folder instead.
	# It works - don't ask why.
	sudo git config --global --add safe.directory /var/www/$domain/html
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to mark $domain as safe using git config --global -add safe.directory."
		echo
		echo $msg
		exit
	fi	

	# To make things simple for our configuration, we want to automatically setup remotes to track local branches when we commit.
	echo "Adding global config option to automatically setup remote branch from new local branches..."
	git config --global --add --bool push.autoSetupRemote true
	if [ $? -ne 0 ]	
	then
		msg="Unable to add global git option push.autoSetupRemote."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	sudo git config --global --add --bool push.autoSetupRemote true
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to add global git option push.autoSetupRemote."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi	

	# start setup git user
	echo "Setting up local user names for git - $git_user_email & $git_display_name..."
	git config user.name $git_user_name
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git user display name."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	git config user.email $git_user_email
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git user email address."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	git config user.password $git_token
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git password/token."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	# end start setup git user

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	# Setup git-ignore.
	lf_create_git_ignore $git_ignore_url $git_exclude_folders $git_exclude_files

	# add all files to repo
	git add . > /dev/null
	if [ $? -ne 0 ]	
	then
		msg="Unable to add files to new local repo."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# commit them
	git commit -m "Initial Commit From Server" > /dev/null
	if [ $? -ne 0 ]	
	then
		msg="Unable to cleanly commit files to local repo."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Add the origin
	echo "Adding origin $git_remote_url"
	git remote add origin $git_remote_url
	if [ $? -ne 0 ]	
	then
		msg="Unable to add remote origin."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# start setup credential helper and store credentials in root folder.
	echo "Setting up git credential helper for user root..."
	git config --global credential.helper 'store --file /root/.git-credentials'
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	sudo git config --global credential.helper 'store --file /root/.git-credentials'
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	git config --global credential.github.com.useHttpPath true 
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	sudo git config --global credential.github.com.useHttpPath true 
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi	

	git config --global credential.bitbucket.com.useHttpPath true
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi
	sudo git config --global credential.bitbucket.com.useHttpPath true
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi	
	# end setup credential helper and store credentials in root folder.

	# strip out https and http out of the url here
	repo_url_without_https=$(echo $git_remote_url |sed 's/https\?:\/\///')
	echo "Repo url without http prefix is $repo_url_without_https"

	# write the credentials out to the helper store.
	# note the .git on the end!
	echo "https://$git_user_name:$git_token@$repo_url_without_https" >> /root/.git-credentials
	if [ $? -ne 0 ]	
	then
		msg="Unable to write to /root/.git_credentials."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Prepare repo for merge.
	git config pull.rebase false
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup repo for merge pull."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Pull from repo
	# Note - this might pause here because it opens an editor.
	echo "Pulling files from remote..."
	git pull --allow-unrelated-histories --no-edit --commit origin $git_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to pull and merge cleanly - $origin branch: $git_branch.  Consider copying files from the repo directly into this site so that it contains the same files as the repo. This will allow a clean merge when initializing the site for use with git."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# push changes
	echo "Pushing to remote..."
	git push --set-upstream origin $git_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to push files to origin cleanly."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Now make sure we're tracking a branch
	git checkout $git_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to checkout branch $git_branch."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi

	# Handle post-processing script
	if [[ -n "$git_post_processing_script_link" ]]
	then
		tmpfile=$(mktemp)
		echo
		echo "Running post-processing script as temp file: $tmpfile"
		wget --quiet --no-check-certificate -O $tmpfile $git_post_processing_script_link
		dos2unix $tmpfile
		bash $tmpfile
	fi

	# Show completion message
	echo
	echo "Git Init Complete For Domain $domain"
	exit
fi

# Remove git from a domain
if [[ $action == "git_domain_remove" || $action == "4" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Remove any existing git working folders.
	lf_remove_git_from_domain $domain
	if [ $? -ne 0 ]
	then
		echo
		echo "Unable to remove git."
		exit
	fi

	# Success
	echo
	echo "Git has been removed from $domain"
	exit
fi

# Git Sync (pull/push)
if [[ $action == "git_sync" || $action == "5" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get commit message - output will be in the $git_commit_msg global var.
	lf_get_commit_message

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	git add .
	if [ $? -ne 0 ]	
	then
		msg="Unable to add files to local repo."
		echo
		echo $msg
		exit
	fi	

	# commit any changes.
	# Note we're not checking errors here since if there are no commits 
	# we'll get a non-zero error code which is not an error in this instance.
	# @TODO: Will this handle a message with spaces?
	git commit -m "$git_commit_msg"

	# Fetch from origin so we know things.
	git fetch origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to fetch from origin."
		echo
		echo $msg
		exit
	fi	

	# Pull from repo
	echo "Pulling files from remote..."
	current_branch=$(git rev-parse --abbrev-ref HEAD)
	git pull origin $current_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to pull from remote"
		echo
		echo $msg
		exit
	fi

	# push changes
	echo "Pushing to remote..."
	git push origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to push files to origin cleanly."
		echo
		echo $msg
		exit
	fi

	echo "Git sync succeeded."
	exit
fi

# Git switch branch and checkout
if [[ $action == "git_checkout" || $action == "6" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get branch - output will be in the $git_branch global var.
	lf_get_git_branch

	# move into the domain folder
	cd /var/www/$domain/html
	lf_navigate_to_domain_folder $domain

	# Fetch from origin first.
	git fetch origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to fetch from origin."
		echo
		echo $msg
		exit
	fi

	# Checkout from remote repo
	echo "Checking out $git_branch from remote repo..."
	git checkout $git_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to checkout $git_branch from remote repo."
		echo
		echo $msg
		exit
	fi

	# Pull from repo
	echo "Pulling files from remote..."
	git pull origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to pull from remote"
		echo
		echo $msg
		exit
	fi	

	echo
	echo "Git branch switch and checkout succeeded."
	exit
fi

# Git new branch and checkout
if [[ $action == "git_new_branch" || $action == "7" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get branch - output will be in the $git_branch global var.
	echo "Specify the source branch name"
	lf_get_git_branch

	# Get new branch - output will be in the $git_new_branch global var
	lf_get_new_git_branch

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	# Fetch from origin first.
	git fetch origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to fetch from origin."
		echo
		echo $msg
		exit
	fi

	# Checkout source from remote repo
	echo "Checking out $git_branch from remote repo..."
	git checkout $git_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to checkout $git_branch from remote repo."
		echo
		echo $msg
		exit
	fi

	# create new branch
	echo "Creating new branch $git_new_branch from $git_branch..."
	git checkout -b $git_new_branch
	if [ $? -ne 0 ]	
	then
		msg="Unable to create $git_new_branch."
		echo
		echo $msg
		exit
	fi
	
	echo
	echo "Git create new branch and checkout succeeded."
	exit
fi

# Git commit and push
if [[ $action == "git_commit_and_push" || $action == "8" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get commit message - output will be in the $git_commit_msg global var.
	lf_get_commit_message	

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	git add .
	if [ $? -ne 0 ]	
	then
		msg="Unable to add files to local repo."
		echo
		echo $msg
		exit
	fi

	# commit any changes.
	# Note we're not checking errors here since if there are no commits 
	# we'll get a non-zero error code which is not an error in this instance.
	# @TODO: Will this handle a message with spaces?
	git commit -m "$git_commit_msg"

	# push changes
	echo "Pushing to remote..."
	git push origin
	if [ $? -ne 0 ]	
	then
		msg="Unable to push files to origin cleanly."
		echo
		echo $msg
		exit
	fi

	echo
	echo "Git commit and push succeeded."
	exit
fi

# Apply tag to current branch
if [[ $action == "git_tag" || $action == "9" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	# Create tag
	echo "Creating tag $git_tag..."
	git tag -a $git_tag -m "Tag $git_tag created from WPCD."
	if [ $? -ne 0 ]	
	then
		msg="Unable to create tag $git_tag."
		echo
		echo $msg
		exit
	fi

	# Push to remote
	echo "Pushing tag to remote..."
	git push origin $git_tag
	if [ $? -ne 0 ]	
	then
		msg="Unable to push tag $git_tag to remote. The tag is stored on the local remote. We will move on and not consider this operation a failure."
		echo
		echo $msg
	fi

	# Create folder where tagged files will go.
	mkdir -p /var/www/$domain/versions/$git_tag
	if [ $? -ne 0 ]
	then
		msg="Could not create folder /var/www/$domain/versions/$git_tag"
		echo
		echo $msg
		exit
	fi

	# Add tagged files to that folder as .zip.
	echo "Creating temporary zip of tagged files..."
	git archive --format=zip --output=/var/www/$domain/versions/$git_tag/$git_tag.zip $git_tag
	if [ $? -ne 0 ]
	then
		msg="Could not create zip file in folder /var/www/$domain/versions/$git_tag/ for tag $git_tag."
		echo
		echo $msg
		exit
	fi

	# Unzip files so they're ready for use later.
	echo "Copying files into the versions folder (/var/www/$domain/versions/$git_tag)"
	unzip -q -o /var/www/$domain/versions/$git_tag/$git_tag.zip -d /var/www/$domain/versions/$git_tag
	if [ $? -ne 0 ]
	then
		msg="Could not unzip tagged files for $git_tag."
		echo
		echo $msg
		exit
	fi

	# Remove zip file.
	rm -f /var/www/$domain/versions/$git_tag/$git_tag.zip

	echo
	echo "Git tag and push succeeded."
	exit
fi

# Pull tag and create version
if [[ $action == "git_fetch_tag" || $action == "10" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# Do it.
	lf_git_fetch_or_pull_tag $domain $git_tag 'standard'

	echo
	echo "Git fetch tag succeeded. Your site files have not changed."
	echo "Use the CHECKOUT action to sync your site files with a version/tag."
	exit
fi

# Remove a version folder
if [[ $action == "git_remove_version_folder" || $action == "11" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	if [[ -z $domain ]]
	then
		msg="We are about to delete a folder but the domain variable is blank. Operation aborted."
		echo
		echo $msg
		exit
	else
		rm -rf /var/www/$domain/versions/$git_tag
	fi

	echo
	echo "Version folder has been removed for $git_tag"
fi

# Remove all version folders
if [[ $action == "git_remove_all_version_folders" || $action == "12" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	if [[ -z $domain ]]
	then
		msg="We are about to delete one or more folders but the domain variable is blank. Operation aborted."
		echo
		echo $msg
		exit
	else
		rm -rf /var/www/$domain/versions/
	fi

	echo
	echo "All version folders have been removed for $domain"
fi

# Display all version folders for a site/domain
if [[ $action == "git_display_domain_version_folders" || $action == "13" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Navigate to the versions folder
	cd /var/www/$domain/versions/
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to the domain version folder or the version folder does not yet exist for the domain $domain."
		echo
		echo $msg
		exit
	fi

	# Get list of folders
	subfolders=($(find . -mindepth 1 -maxdepth 1 -type d))

	for folder in "${subfolders[@]}"; do
		echo $folder
	done	
fi

# Display current branch
if [[ $action == "git_get_current_branch" || $action == "14" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# move into the domain folder
	lf_navigate_to_domain_folder $domain

	current_branch=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z $current_branch ]]; then
		$msg="No current branch!"
		echo
		echo $msg
		exit
	else
		echo $current_branch
	fi
fi

# Apply version to domain by overwriting domain files directly.
# Important note: We're not switching the branch. So if the 
# tag is older or for a different branch, things can get really 
# weird.
# 
# To apply a version and sync the git branch with it
# use the get_pull_apply_version_with_overwrite action.
#
# Also Note that this is not a bi-directional sync so files that are in 
# the target domain but not in the tag will remain in the target domain folder
# (Except for plugins and themes)
if [[ $action == "git_fetch_apply_version_with_overwrite" || $action == "15" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# Calculate user name - we'll need it later.
	# @TODO: Replace this with gf_get_domain_user_name
	user_name=$(echo $domain | cut -c1-32)

	# Get pre and post-processing links - output will be in global vars $git_pre_processing_script_link & $git_post_processing_script_link respectively
	lf_get_git_pre_processing_script_link
	lf_get_git_post_processing_script_link

	# Make sure we have a version of the specified tag in a versions folder
	# @TODO: In a future version of this script we will pass a param to allow this step to be skipped.
	lf_git_fetch_or_pull_tag $domain $git_tag 'standard'

	# Add wp .maintenance file here to domain.
	gf_set_maintenance_mode_for_site $domain

	# rsync the files
	echo "Copying files to domain $domain..."
	rsync -au --quiet --stats /var/www/$domain/versions/$git_tag/ /var/www/$domain/html/

	# Special handling for the plugins, mu_plugins & themes folder
	# Yes, we know, this duplicates some of the work in the rsync line above.
	# Better this way for clarity than to write something fancy no one can understand later.
	echo "Removing non-matching files from the plugins folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/versions/$git_tag/wp-content/plugins/ /var/www/$domain/html/wp-content/plugins/
	echo "Removing non-matching files from the mu-plugins folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/versions/$git_tag/wp-content/mu-plugins/ /var/www/$domain/html/wp-content/mu-plugins/
	echo "Removing non-matching files from the themes folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/versions/$git_tag/wp-content/themes/ /var/www/$domain/html/wp-content/themes/

	# reset file permissions
	gf_reset_file_permissions_for_domain $domain

	# Remove wp .maintenance file here from domain.
	gf_remove_maintenance_mode_for_site $domain

	# flush caches
	echo
	echo "Flushing caches..."
	g_flush_cache $user_name $domain

	echo
	echo "Git switch version succeeded."
	exit
fi

# Apply version to domain by overwriting domain files directly.
#
# ***This is not currently used or fully tested.***
#
# Also Note that this is not a bi-directional sync so files that are in 
# the target domain but not in the tag will remain in the target domain folder
# (Except for plugins and themes)
if [[ $action == "git_pull_checkout_and_apply_version_with_overwrite" || $action == "16" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# Calculate user name - we'll need it later.
	# @TODO: Replace this with gf_get_domain_user_name
	user_name=$(echo $domain | cut -c1-32)

	# Get pre and post-processing links - output will be in global vars $git_pre_processing_script_link & $git_post_processing_script_link respectively
	lf_get_git_pre_processing_script_link
	lf_get_git_post_processing_script_link

	# Add wp .maintenance file here to domain.
	gf_set_maintenance_mode_for_site $domain

	# Pull and checkout the tag.
	# @TODO: In a future version of this script we will pass a param to allow this step to be skipped.
	lf_git_fetch_or_pull_tag $domain $git_tag 'standard' 'pull'

	# Notice the lack of RSYNC here.
	# PULLING & Checking out automatically syncs the files to the repo.

	# reset file permissions
	gf_reset_file_permissions_for_domain $domain

	# Remove wp .maintenance file here from domain.
	gf_remove_maintenance_mode_for_site $domain

	# flush caches
	echo
	echo "Flushing caches..."
	g_flush_cache $user_name $domain

	echo
	echo "Git switch version succeeded."
	exit
fi

# Set up git credentials for a site but do not sync or clone.
# Useful if site credentials change.
# Note that a lot of this logic is also in option 1.
# So if things change there or here check the other one.
if [[ $action == "git_site_credentials" || $action == "17" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get credentials and other vars
	lf_get_git_user_email						# Sets Global $git_user_email
	lf_get_git_display_name						# Sets Global $git_display_name
	lf_get_git_username							# Sets Global $git_user_name
	lf_get_git_remote_url						# Sets Global $git_remote_url
	lf_get_git_token							# Sets Global $git_token

	# Make a git working folder outside of the folder where files are usually located.
	# We will NOT be backing up this folder.
	mkdir -p /var/www/$domain/.wpcd_git
	if [ $? -ne 0 ]
	then
		msg="Could not create folder $domain/.wpcd_git"
		echo
		echo $msg
		exit
	fi

	# Move into git working folder.
	cd /var/www/$domain/.wpcd_git
	if [ $? -ne 0 ]
	then
		msg="Could not move into folder /var/www/$domain/.wpcd_git."
		echo
		echo $msg
		exit
	fi		

	# Initialize git and check for error.
	# Note that we're not specifying a branch here like we do with the init option.
	# We don't really care about branches - we just want to initialize git enough
	# to get to the point where we can save the credentials to the credential
	# store. 
	# It can't do that without a git folder being active though.  So we do
	# a git init that will be overwritten if we ever run our full
	# git init action (menu option #1).
	git init --separate-git-dir . ../html/
	if [ $? -ne 0 ]
	then
		msg="Could not initialize repo."
		echo
		echo $msg
		lf_send_callback_failed $git_callback_url "$msg"
		exit
	fi	

	# Since $domain and .wpcd_git are owned by different users (root vs limited user), need to mark $domain as safe.
	echo "Adding global safe.directory variable for domain $domain..."
	git config --global --add safe.directory /var/www/$domain/html
	if [ $? -ne 0 ]	
	then
		msg="Unable to mark $domain as safe using git config --global -add safe.directory."
		echo
		echo $msg
		exit
	fi

	# Even if this script is called with 'sudo', git will write the global data
	# to the sudo (eg: ubuntu) folder. So nest sudo calls which will 
	# force it to write to the root home folder instead.
	# It works - don't ask why.
	sudo git config --global --add safe.directory /var/www/$domain/html
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to mark $domain as safe using git config --global -add safe.directory."
		echo
		echo $msg
		exit
	fi

	# start setup git user
	echo "Setting up local user names for git - $git_user_email & $git_display_name..."
	git config user.name $git_display_name
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git user display name."
		echo
		echo $msg
		exit
	fi
	git config user.email $git_user_email
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git user email address."
		echo
		echo $msg
		exit
	fi
	git config user.password $git_token
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git password/token."
		echo
		echo $msg
		exit
	fi
	# end start setup git user

	# start setup credential helper and store credentials in root folder.
	echo "Setting up git credential helper for user root..."
	git config --global credential.helper 'store --file /root/.git-credentials'
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper."
		echo
		echo $msg
		exit
	fi
	sudo git config --global credential.helper 'store --file /root/.git-credentials'
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper."
		echo
		echo $msg
		exit
	fi	

	git config --global credential.github.com.useHttpPath true 
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		exit
	fi
	sudo git config --global credential.github.com.useHttpPath true 
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		exit
	fi	

	git config --global credential.bitbucket.com.useHttpPath true
	if [ $? -ne 0 ]	
	then
		msg="Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		exit
	fi
	sudo git config --global credential.bitbucket.com.useHttpPath true
	if [ $? -ne 0 ]	
	then
		msg="(Running under sudo) Unable to setup git credential helper - param useHttpPath"
		echo
		echo $msg
		exit
	fi	
	# end setup credential helper and store credentials in root folder.

	# strip out https and http out of the url here
	repo_url_without_https=$(echo $git_remote_url |sed 's/https\?:\/\///')
	echo "Repo url without http prefix is $repo_url_without_https"

	# write the credentials out to the helper store.
	# note the .git on the end!
	echo "https://$git_user_name:$git_token@$repo_url_without_https" >> /root/.git-credentials
	if [ $? -ne 0 ]	
	then
		msg="Unable to write to /root/.git_credentials."
		echo
		echo $msg
		exit
	fi	

	echo
	echo "Git credentials successfully set up for domain $domain."
	exit
fi

# Clone a repo to a site but don't setup git for it or 
# sync to it.
# Assumes git credentials have been setup already.
if [[ $action == "git_clone_to_site" || $action == "18" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get remote url - output will be in the $git_remote_url global var.
	lf_get_git_remote_url

	# Get branch - output will be in the $git_branch global var.
	lf_get_git_branch

	# Calculate user name - we'll need it later.
	# @TODO: Replace this with gf_get_domain_user_name
	user_name=$(echo $domain | cut -c1-32)

	# Remove any existing folders
	if [[ -z $domain ]]
	then
		msg="We are about to delete a folder but the domain variable is blank. Operation aborted."
		echo
		echo $msg
		exit
	else
		rm -rf /var/www/$domain/git-clones/$git_branch
	fi

	# Create a clones folder where the cloned files will be located
	mkdir -p /var/www/$domain/git-clones/$git_branch
	if [ $? -ne 0 ]
	then
		msg="Could not create folder /var/www/$domain/git-clones/$git_branch"
		echo
		echo $msg
		exit
	fi

	# Clone
	git clone $git_remote_url /var/www/$domain/git-clones/$git_branch
	if [ $? -ne 0 ]
	then
		msg="Could not create clone from $git_remote_url for domain $domain."
		echo
		echo $msg
		exit
	fi

	# Add wp .maintenance file here to domain.
	gf_set_maintenance_mode_for_site $domain

	# rsync the files
	echo "Copying files to domain $domain..."
	rsync -au --quiet --stats /var/www/$domain/git-clones/$git_branch/ /var/www/$domain/html/

	# Special handling for the plugins, mu_plugins & themes folder
	# Yes, we know, this duplicates some of the work in the rsync line above.
	# Better this way for clarity than to write something fancy no one can understand later.
	echo "Removing non-matching files from the plugins folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/git-clones/$git_branch/wp-content/plugins/ /var/www/$domain/html/wp-content/plugins/
	echo "Removing non-matching files from the mu-plugins folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/git-clones/$git_branch/wp-content/mu-plugins/ /var/www/$domain/html/wp-content/mu-plugins/
	echo "Removing non-matching files from the themes folder for $domain..."
	rsync -au --quiet --delete --stats /var/www/$domain/git-clones/$git_branch/wp-content/themes/ /var/www/$domain/html/wp-content/themes/

	# reset file permissions
	gf_reset_file_permissions_for_domain $domain

	# Remove wp .maintenance file here from domain.
	gf_remove_maintenance_mode_for_site $domain

	# flush caches
	echo
	echo "Flushing caches..."
	g_flush_cache $user_name $domain

	echo
	echo "Git clone successful"
	exit
fi

#################################################################
# Multi-tenant specific actions to here.
#
# We start by creating MT functions followed by
# the menu actions.
#################################################################


########################################################
# Given a domain, backup its folders and files before
# converting it to a multi-tenant install.
#
# @param $1 domain
# @param $2 template_domain
# @param $3 tag
########################################################
lf_mt_backup_existing_folders_before_site_conversion() {

	# setup local variables from parameters passed in.
	local domain
	domain=$1

	local mt_template_domain
	mt_template_domain=$2

	local git_tag
	git_tag=$3
 	# end setup local variables from parameters passed in.

	# Create var for the MT version folder.
	mt_version_folder="/var/wpcd-mt-versions/$mt_template_domain/versions/$git_tag"

	# Create var for the domain files folder.
	mt_domain_files_folder="/var/www/$domain/html"

	# Date stamped backup folder var
	local target_subdir
	target_subdir=$(date +%Y-%m-%d-%H:%M:%S)

	# Start moving files.
	echo "****************************************************************************************"
	echo "Backing up existing folders into $mt_domain_files_folder/wpcd-originals/$target_subdir"
	echo "****************************************************************************************"
	mkdir -p "$mt_domain_files_folder/wpcd-originals/$target_subdir"
	if [ $? -ne 0 ]
	then
		msg="Unable to make folder: $mt_domain_files_folder/wpcd-originals/$target_subdir"
		echo
		echo $msg
		exit
	fi
	echo " 1. Plugins"
	if [ -d "$mt_domain_files_folder/wp-content/plugins" ]; then
		echo "  ...found - moving..."
		mv "$mt_domain_files_folder/wp-content/plugins" "$mt_domain_files_folder/wpcd-originals/$target_subdir"
		if [ $? -ne 0 ]
		then
			msg="Unable to move folders from: $mt_domain_files_folder/wp-content/plugins to $mt_domain_files_folder/wpcd-originals/$target_subdir"
			echo
			echo $msg
			exit
		fi
	fi
	echo " 2. Themes"
	if [ -d "$mt_domain_files_folder/wp-content/themes" ]; then
		echo "  ...found - moving..."	
		mv "$mt_domain_files_folder/wp-content/themes" "$mt_domain_files_folder/wpcd-originals/$target_subdir"
		if [ $? -ne 0 ]
		then
			msg="Unable to move folders from: $mt_domain_files_folder/wp-content/themes to $mt_domain_files_folder/wpcd-originals/$target_subdir"
			echo
			echo $msg
			exit
		fi
	fi

	echo " 3. mu-plugins"
	if [ -d "$mt_domain_files_folder/wp-content/mu-plugins" ]; then
		echo "  ...found - moving..."	
		mv "$mt_domain_files_folder/wp-content/mu-plugins" "$mt_domain_files_folder/wpcd-originals/$target_subdir"
		if [ $? -ne 0 ]
		then
			msg="Unable to move folders from: $mt_domain_files_folder/wp-content/mu-plugins to $mt_domain_files_folder/wpcd-originals/$target_subdir"
			echo
			echo $msg
			exit
		fi
	fi

	echo " 5. WPCore - wp-admin"
	if [ -d "$mt_domain_files_folder/wp-admin" ]; then
		echo "  ...found - moving..."	
		mv "$mt_domain_files_folder/wp-admin" "$mt_domain_files_folder/wpcd-originals/$target_subdir"
		if [ $? -ne 0 ]
		then
			msg="Unable to move folders from: $mt_domain_files_folder/wp-admin to $mt_domain_files_folder/wpcd-originals/$target_subdir"
			echo
			echo $msg
			exit
		fi
	else
		msg="Unable to locate and backup $mt_domain_files_folder/wp-admin. Moving on... "
		echo
		echo $msg
		echo
	fi

	echo " 6. WPCore - wp-includes"
	if [ -d "$mt_domain_files_folder/wp-includes" ]; then
		echo "  ...found - moving..."	
		mv "$mt_domain_files_folder/wp-includes" "$mt_domain_files_folder/wpcd-originals/$target_subdir"
		if [ $? -ne 0 ]
		then
			msg="Unable to move folders from: $mt_domain_files_folder/wp-includes to $mt_domain_files_folder/wpcd-originals/$target_subdir"
			echo
			echo $msg
			exit
		fi
	else
		msg="Unable to locate and backup $mt_domain_files_folder/wp-includes. Moving on... "
		echo
		echo $msg
		echo
	fi

	echo " 6. WPCore - selected individual files in root"
	local core_files
	core_files=( 'index.php' 'license.txt' 'readme.html' 'wp-activate.php' 'wp-signup.php' 'wp-blog-header.php' 'wp-comments-post.php' 'wp-config-sample.php' 'wp-cron.php' 'wp-links-opml.php' 'wp-load.php' 'wp-login.php' 'wp-mail.php' 'wp-settings.php' 'wp-signup.ph' 'wp-trackback.php' 'xmlrpc.php' )
	cd $mt_domain_files_folder
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_domain_files_folder"
		echo
		echo $msg
		exit
	fi
	for core_file in "${core_files[@]}"
	do
		if [ -f "$core_file" ]; then	
			mv "$mt_domain_files_folder/$core_file" "$mt_domain_files_folder/wpcd-originals/$target_subdir/$core_file"
			if [ $? -ne 0 ]
			then
				msg="Unable to move file from: $mt_domain_files_folder/$core_file to $mt_domain_files_folder/wpcd-originals/$target_subdir/$core_file"
				echo
				echo $msg
				exit
			fi
		else
			msg="Core WP file not found in domain folder ($core_file) - moving on."
		fi
	done

	echo " 7. Matching other template files in template root"
	if [ -d "$mt_version_folder" ]; then
		cd $mt_version_folder
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder"
			echo
			echo $msg
			exit
		fi

		for template_file in $(find . -maxdepth 1 -type f -not -name ".*"); do
			# Remove all leading periods and slashes from file name
			no_slash_file_name=$(basename "$template_file")

			# Skip certain files - not used right now but might be in the future.
			local skip_files
			skip_files=('none')
			if [[ $(printf "_[%s]_" "${skip_files[@]}") =~ .*_\[$no_slash_file_name\]_.* ]]
			then 			
					echo "   ...SKIPPING file found in both source version and target domain: $no_slash_file_name because it is in the skip_files list..."
					continue
			fi

			# does a corresponding file exist in the domain root folder?
			if [ -f "$mt_domain_files_folder/$no_slash_file_name" ]; then		

				# move it out of the domain folder
				echo "   ...found file in both source version and target domain: $no_slash_file_name - moving it out of target domain..."
				mv "$mt_domain_files_folder/$no_slash_file_name" "$mt_domain_files_folder/wpcd-originals/$target_subdir/$no_slash_file_name"
			fi
		done
	fi

	echo " 8. WPCore - selected individual files in wp-content root"
	local core_files
	core_files=( 'advanced-cache.php' 'object-cache.php' )
	cd $mt_domain_files_folder/wp-content
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_domain_files_folder/wp-content"
		echo
		echo $msg
		exit
	fi

	# Make wp-content folder in the $target_subdir since it likely does not exist at this point.
	mkdir -p $mt_domain_files_folder/wpcd-originals/$target_subdir/wp-content	

	for core_file in "${core_files[@]}"
	do
		if [ -f "$core_file" ]; then	
			mv "$mt_domain_files_folder/wp-content/$core_file" "$mt_domain_files_folder/wpcd-originals/$target_subdir/wp-content/$core_file"
			if [ $? -ne 0 ]
			then
				msg="Unable to move file from: $mt_domain_files_folder/$core_file to $mt_domain_files_folder/wpcd-originals/$target_subdir/wp-content/$core_file"
				echo
				echo $msg
				exit
			fi
		else
			msg="Core WP file not found in domain folder ($core_file) - moving on."
		fi
	done

	echo " 9. Matching other template files in template wp-content"
	if [ -d "$mt_version_folder/wp-content" ]; then
		cd $mt_version_folder/wp-content
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder/wp-content"
			echo
			echo $msg
			exit
		fi

		if [ $? -ne 0 ]
		then
			msg="Unable to make folder: $mt_domain_files_folder/wpcd-originals/$target_subdir/wp-content"
			echo
			echo $msg
			exit
		fi

		for template_file in $(find . -maxdepth 1 -type f -not -name ".*"); do
			# Remove all leading periods and slashes from file name
			no_slash_file_name=$(basename "$template_file")

			# Skip certain files.
			local skip_files
			skip_files=('index.php')
			if [[ $(printf "_[%s]_" "${skip_files[@]}") =~ .*_\[$no_slash_file_name\]_.* ]]
			then 			
					echo "   ...SKIPPING file found in both source version and target domain: $no_slash_file_name because it is in the skip_files list..."
					continue
			fi			

			# does a corresponding file exist in the domain root folder?
			if [ -f "$mt_domain_files_folder/wp-content/$no_slash_file_name" ]; then		
				# move it out of the domain folder
				echo "   ...found file in both source version and target domain: $no_slash_file_name - moving it out of target domain..."
				mv "$mt_domain_files_folder/wp-content/$no_slash_file_name" "$mt_domain_files_folder/wpcd-originals/$target_subdir/wp-content/$no_slash_file_name"
			fi
		done
	fi

	echo "****************************************************************************************"
	echo "Backup of existing files complete."
	echo "****************************************************************************************"
}


########################################################
# Given a domain, template domain and version, link
# the files in the plugins, themes and core folders
# to the domain. 
#
# Note that for plugins, themes and mu-plugins folders
# we are linking the individual subfolders.
#
# @param $1 domain
# @param $2 template_domain
# @param $3 tag
########################################################
lf_mt_site_conversion_link_existing_files() {

	# setup local variables from parameters passed in.
	local domain
	domain=$1

	local mt_template_domain
	mt_template_domain=$2

	local git_tag
	git_tag=$3
 	# end setup local variables from parameters passed in.

	# Figure out the MT version folder.
	mt_version_folder="/var/wpcd-mt-versions/$mt_template_domain/versions/$git_tag"

	# Figure out the domain files folder.
	mt_domain_files_folder="/var/www/$domain/html"

	# Start: Add new folders
	echo "Adding new blank folders for symlinks..."
	echo " 1. Plugins"
	mkdir -p "$mt_domain_files_folder/wp-content/plugins"
	if [ $? -ne 0 ]
	then
		msg="Unable to add new plugins folder: $mt_domain_files_folder/wp-content/plugins"
		echo
		echo $msg
		exit
	fi

	echo " 2. Themes"
	mkdir -p "$mt_domain_files_folder/wp-content/themes"
	if [ $? -ne 0 ]
	then
		msg="Unable to add new themes folder: $mt_domain_files_folder/wp-content/themes"
		echo
		echo $msg
		exit
	fi

	echo " 3. mu-plugins"
	mkdir -p "$mt_domain_files_folder/wp-content/mu-plugins"
	if [ $? -ne 0 ]
	then
		msg="Unable to add new mu-plugins folder: $mt_domain_files_folder/wp-content/mu-plugins"
		echo
		echo $msg
		exit
	fi		
	# End: Add new folders

	# Start: Move files & create symlinks
	echo "Moving files and creating soft symlinks from mt-versions..."
	echo " 1. Plugins"
	cd "$mt_version_folder/wp-content/plugins/"
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_version_folder/wp-content/plugins/"
		echo
		echo $msg
		exit
	fi	
	for dir in $(find . -maxdepth 1 -type d -not -name ".*"); do
		# Create a symbolic link to the subdirectory in the target directory
		if [ -d "$dir" ]; then
			local no_slash_folder_name
			no_slash_folder_name=$(basename "$dir")
			echo "   ...found plugin in source version: $no_slash_folder_name - linking it."
			ln -s "$mt_version_folder/wp-content/plugins/$no_slash_folder_name" "$mt_domain_files_folder/wp-content/plugins/$no_slash_folder_name"
		fi
	done


	echo " 2. Themes"
	cd "$mt_version_folder/wp-content/themes/"
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_version_folder/wp-content/themes/"
		echo
		echo $msg
		exit
	fi	
	for dir in $(find . -maxdepth 1 -type d -not -name ".*"); do
		# Create a symbolic link to the subdirectory in the target directory
		if [ -d "$dir" ]; then
			local no_slash_folder_name
			no_slash_folder_name=$(basename "$dir")
			echo "   ...found theme in source version: $no_slash_folder_name - linking it."
			ln -s "$mt_version_folder/wp-content/themes/$no_slash_folder_name" "$mt_domain_files_folder/wp-content/themes/$no_slash_folder_name"
		fi
	done

	echo " 3. mu-plugins"
	if [ -d "$mt_version_folder/wp-content/mu-plugins" ]; then	
		echo "    ...mu-plugins exist in source version - linking it."
		cd "$mt_version_folder/wp-content/mu-plugins/"
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder/wp-content/mu-plugins/"
			echo
			echo $msg
			exit
		fi	
		for dir in $(find . -maxdepth 1 -type d -not -name ".*"); do
			# Create a symbolic link to the subdirectory in the target directory
			if [ -d "$dir" ]; then
				local no_slash_folder_name
				no_slash_folder_name=$(basename "$dir")
				echo "      ...found mu-plugin in source version: $no_slash_folder_name - linking it."
				ln -s "$mt_version_folder/wp-content/mu-plugins/$no_slash_folder_name" "$mt_domain_files_folder/wp-content/mu-plugins/$no_slash_folder_name"
			fi
		done
	else
		echo  "   ...no mu-plugins folder exist in source version, moving on."
	fi

	###################################################################################################
	# Core files should be COPIED to the site to make sure we're on the same version as the template.
	###################################################################################################
	echo " 4. WPCore - wp-admin"
	echo "      ...Copying to site..."
	cd "$mt_version_folder/"
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_version_folder/"
		echo
		echo $msg
		exit
	fi
	cp -r "$mt_version_folder/wp-admin" "$mt_domain_files_folder"

	echo " 5. WPCore - wp-includes"
	echo "      ...Copying to site..."
	cd "$mt_version_folder/"
	if [ $? -ne 0 ]
	then
		msg="Unable to navigate to $mt_version_folder/"
		echo
		echo $msg
		exit
	fi
	cp -r "$mt_version_folder/wp-includes" "$mt_domain_files_folder/"

	echo " 6. WPCore files from version root"
	core_files=('index.php' 'license.txt' 'readme.html' 'wp-activate.php' 'wp-signup.php' 'wp-blog-header.php' 'wp-comments-post.php' 'wp-config-sample.php' 'wp-cron.php' 'wp-links-opml.php' 'wp-load.php' 'wp-login.php' 'wp-mail.php' 'wp-settings.php' 'wp-signup.ph' 'wp-trackback.php' 'xmlrpc.php')	
	if [ -d "$mt_version_folder" ]; then	
		echo "    ...copying..."
		cd "$mt_version_folder/"
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder/"
			echo
			echo $msg
			exit
		fi	
		for core_file in "${core_files[@]}"
		do
			if [ -f "$core_file" ]; then	
				cp "$mt_version_folder/$core_file" "$mt_domain_files_folder/$core_file"
				if [ $? -ne 0 ]
				then
					msg="Unable to copy file from: $mt_version_folder/$core_file to $mt_version_folder/$core_file. Moving on..."
					echo
					echo $msg
				fi
			else
				msg="Core WP file not found in versions folder ($core_file) - moving on."
			fi
		done
	else
		echo  "   ...This should not happen at this point - the $mt_version_folder root has disappeared?."
	fi

	echo " 7. Files in template root"
	if [ -d "$mt_version_folder" ]; then	
		echo "    ...Linking template root files."
		cd "$mt_version_folder/"
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder/"
			echo
			echo $msg
			exit
		fi	
		for core_file in $(find . -maxdepth 1 -type f -not -name ".*" -not -name ".sh"); do
			# Create a symbolic link to the files in the target directory
			if [ -f "$core_file" ]; then
				local no_slash_file_name
				no_slash_file_name=$(basename "$core_file")

				# Skip core files (list defined in step 6 above.)
				if [[ $(printf "_[%s]_" "${core_files[@]}") =~ .*_\[$no_slash_file_name\]_.* ]]
				then 			
						echo "      ...Not linking file: $no_slash_file_name because it is a core WP file..."
						continue
				fi

				echo "      ...found file in source version: $no_slash_file_name - linking it."
				ln -s "$mt_version_folder/$no_slash_file_name" "$mt_domain_files_folder/$no_slash_file_name"
			fi
		done
	else
		echo  "   ...This should not happen at this point - the $mt_version_folder root has disappeared?."
	fi

	echo " 8. Files in template wp-content"
	if [ -d "$mt_version_folder/wp-content" ]; then	
		echo "    ...Linking template wp-content root files."
		cd "$mt_version_folder/wp-content/"
		if [ $? -ne 0 ]
		then
			msg="Unable to navigate to $mt_version_folder/wp-content/"
			echo
			echo $msg
			exit
		fi	
		for core_file in $(find . -maxdepth 1 -type f -not -name ".*" -not -name ".sh"); do
			# Create a symbolic link to the files in the target directory
			if [ -f "$core_file" ]; then
				local no_slash_file_name
				no_slash_file_name=$(basename "$core_file")

				# Skip files (list defined in step 6 above.)
				skip_files=('index.php')
				if [[ $(printf "_[%s]_" "${skip_files[@]}") =~ .*_\[$no_slash_file_name\]_.* ]]
				then 			
						echo "      ...Not linking file: $no_slash_file_name because it is a core WP file..."
						continue
				fi

				echo "      ...found file in source version: $no_slash_file_name - linking it."
				ln -s "$mt_version_folder/wp-content/$no_slash_file_name" "$mt_domain_files_folder/wp-content/$no_slash_file_name"
			fi
		done
	else
		echo  "   ...This should not happen at this point - the $mt_version_folder root has disappeared?."
	fi		
	# End: Create symlinks.

}


# Pull tag and create muti-tenant version.
# This is different from optin 10 (get_fetch_tag) in that 
# the files go into a different folder.
if [[ $action == "mt_git_fetch_tag" || $action == "21" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# Do it.
	lf_git_fetch_or_pull_tag $domain $git_tag 'mt'

	echo
	echo "Multi-tenant: Fetch version succeeded."
	exit
fi

# Convert a site to a multi-tenant site.
if [[ $action == "mt_convert_site" || $action == "22" ]]
then
	# Get domain - output will be in the $domain global var.
	lf_select_domain

	# Get tag - output will be in the $git_tag var.
	lf_get_tag

	# Get template domain - output will be in $mt_template_domain
	lf_mt_get_template_domain

	# Get the domain user name - output will be held in $g_domain_user_name
	gf_get_domain_user_name $domain
	user_name=$g_domain_user_name

	# Figure out the MT version folder.
	mt_version_folder="/var/wpcd-mt-versions/$mt_template_domain/versions/$git_tag"

	# Figure out the domain files folder.
	mt_domain_files_folder="/var/www/$domain/html"

	# Verify that MT version folder exists.
	if [ ! -d "$mt_version_folder" ]; then
		echo "We could not find the versions folder: $mt_version_folder"
		exit
	fi

	# Verify that domain exists.
	if [ ! -d "$mt_domain_files_folder" ]; then
		echo "We could not find the domain files folder: $mt_domain_files_folder"
		exit
	fi

	# Start move-backup of existing folders
	lf_mt_backup_existing_folders_before_site_conversion $domain $mt_template_domain $git_tag

	# link files and folders from template version into domain
	# @TODO: Check to see if versions folder has a custom copy script file.
	# If so, use that instead of this one.
	lf_mt_site_conversion_link_existing_files $domain $mt_template_domain $git_tag

	# return back to where we were which should be, ~
	cd ~

	# Now lets make sure www-data has access to the multi-tenant source files.
	# It's important that this is readonly.
	# The php openbase directive will allow access to these folders. 
	# We don't want an escapee to be able to write to it.
	chgrp -R www-data "$mt_version_folder"
	chmod -R g+r "$mt_version_folder"

	# Modify the php openbase directive to allow multi-tenant folder to be accessed.
	# delete openbase directive.
	if [ "$g_webserver_type" = "nginx" ]
	then	
		phpversion=(5.6 7.1 7.2 7.3 7.4 8.0 8.1)
		for ver in "${phpversion[@]}"
		do	
			if [ -f /etc/php/$ver/fpm/pool.d/$domain.conf ]; then
				echo "Updating open_basedir in /etc/php/$ver/fpm/pool.d/$domain.conf to allowing reading from the multi-tenant version folder."
				sed -i '/open_basedir/d' /etc/php/$ver/fpm/pool.d/$domain.conf
				# add the new one back in.
				echo "php_admin_value[open_basedir] = \"/var/www/$domain/html/:/tmp/:$mt_version_folder/\"" >> /etc/php/$ver/fpm/pool.d/$domain.conf
				# restart fpm
				sudo systemctl restart php$ver-fpm
			fi
		done
	elif [ "$g_webserver_type" = "ols" ]  || [ "$g_webserver_type" = "ols-enterprise" ]
	then
		echo "ols-is not supported - this operation probably broke your ols site."
		# search and replace needs to be done in this file: ${VHDIR}/${$domain}/$g_vhost_conf 
		# search for php_admin_value open_basedir "/var/www/$domain/html:/tmp/"
		# replace with php_admin_value open_basedir "/var/www/$domain/html:/tmp/:$mt_version_folder/"
	fi

	# Prevent WP from attempting to upgrade things.
	echo "Setting wp-config.php constants to prevent auto-upgrading things..."
	su - "$user_name" -c "wp --skip-plugins --no-color config set WP_AUTO_UPDATE_CORE false --raw"
	su - "$user_name" -c "wp --skip-plugins --no-color config set DISALLOW_FILE_EDIT false --raw"

	# @TODO: Did the version folder have a custom site wp-config.php file?
	# If so, include it in the site wp-config.php file

	# Check meta to see if this site was an MT site before - returns value in global $wpcd_metavalue
	gf_get_metadata -t 'domain' -d $domain -k 'IS_MT' -f '0', 
	is_meta=$wpcd_metavalue

	# Run any post-processing scripts in the template version folder
	if [ "$is_meta" = "1" ]
	then
		# This site was already an MT site. Run upgrade post-processing script if it exists.
		# xxx-upgrade.sh
		echo "This is is an existing Multi-Tenant site - checking for upgrade script..."
	else
		# New MT site, run conversion post-processing script.
		# xxx-convert.sh
		echo "This is is a new Multi-Tenant site - checking for new install post-processing script..."

		# Set meta to note that this site is an MT site.
		gf_set_domain_metadata "IS_MT" '1' $domain
	fi

	# restart the web server.
	gf_restart_webserver

	# @TODO: Install and run our custom plugin that will have life-cycle action hooks.
	# Trigger either the new install action hook or the upgrade action hook.
	# Pass in the git tag to the hook.

	echo
	echo "Multi-tenant: Site conversion succeeded for $domain."
	exit
fi